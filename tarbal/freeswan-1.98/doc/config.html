<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Introduction to FreeS/WAN</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso-8859-1">
<STYLE TYPE="text/css"><!--
BODY { font-family: serif }
H1 { font-family: sans-serif }
H2 { font-family: sans-serif }
H3 { font-family: sans-serif }
H4 { font-family: sans-serif }
H5 { font-family: sans-serif }
H6 { font-family: sans-serif }
SUB { font-size: smaller }
SUP { font-size: smaller }
PRE { font-family: monospace }
--></STYLE>
</HEAD>
<BODY>
<A HREF="toc.html">Contents</A>
<A HREF="install.html">Previous</A>
<A HREF="background.html">Next</A>
<HR>
<H1><A name="setup">Configuration</A></H1>
<P>This section describes setting up and testing Linux FreeS/WAN.</P>
<P>This document is almost obsolete. It is being replaced by our new<A href="quickstart.html">
 Quickstart Guide</A>. We recommend that most users use that.</P>
<P>There are separate documents on<A href="testing.html"> testbed
 configurations</A> and<A href="performance.html"> performance
 measurement</A> which some users may want to consult along with this
 one. If you just want to get a few connections up, this document should
 have everything you need.</P>
<P>Before attempting this, you should:</P>
<UL>
<LI>look at our<A href="intro.html"> introduction</A> section. We assume
 here that you understand concepts and terms described there.</LI>
<LI>ensure that FreeS/WAN is installed on your system. See these links:
<UL>
<LI><A href="install.html#testinstall">testing</A> whether FreeS/WAN is
 installed</LI>
<LI>performing an<A href="install.html"> installation</A></LI>
</UL>
</LI>
</UL>
<P>You also need to set up and test IP networking on all the machines
 you plan to install FreeS/WAN on or to use in testing, before trying to
 set up FreeS/WAN.</P>
<H2><A name="example.simple">Our example networks</A></H2>
<P>In our examples, we describe a setup with three networks -- two that
 want to talk to each other plus the Internet in the middle. The idea is
 to build an encrypted tunnel across the Internet so the two networks
 can talk securely.</P>
<P>We'll call the two gateways East and West. We'll have a client
 machine on each net: Sunrise in the East and Sunset in the West.</P>
<PRE>     Sunset==========West------------------East=========Sunrise
           local net       untrusted net       local net</PRE>
<P>Of course one does not always have a security gateway separate from
 the client machine. It is also quite common to use IPsec on a network
 that looks like this:</P>
<PRE>                                           telecommuter's PC or
                                           traveller's laptop
     Sunset==========West------------------East
         corporate LAN     untrusted net</PRE>
<P>We treat this setup as degenerate cases of the network-to-network
 link. The East computer is a gateway for a one-client subnet, and it is
 also the client.</P>
<P>Our goal here is to tell you how to set up the two gateways, East and
 West. We assume your goal is to ensure that East and West encrypt all
 traffic between them.</P>
<P>More complicated network configurations are described later.</P>
<H2><A name="setupnet">Set up and test networking</A></H2>
<P>Before trying to get FreeS/WAN working, you should configure and test
 IP networking on both gateways and on at least one client machine
 behind each of them.<STRONG> IPsec cannot work without a working IP
 network beneath it.</STRONG></P>
<P>Many reported &quot;FreeS/WAN problems&quot; turn out to actually be problems
 with routing or firewalling. If any actual IPsec problems turn up, you
 often cannot even recognise them (much less debug them) unless the
 underlying network is right.</P>
<P>If you need advice on this, your best sources are likely:</P>
<UL>
<LI>the<A href="http://www.linuxdoc.org/HOWTO/Net-HOWTO/index.html">
 Networking Howto</A></LI>
<LI>the<A href="http://www.linuxdoc.org/LDP/nag2/index.html"> Network
 Administrator's Guide</A>.</LI>
<LI>the<A href="http://netfilter.samba.org/unreliable-guides/networking-concepts-HOWTO/index.html">
 Linux Networking-concepts HOWTO</A> from Rusty Russell, author of most
 of the Linux firewalling code</LI>
</UL>
<P>See also our<A href="biblio.html"> bibliography</A>.</P>
<P>Here is our network diagram again:</P>
<PRE>        Sunset==========West------------------East=========Sunrise
              local net       untrusted net       local net</PRE>
<P>The client machines, Sunrise and Sunset in our example, may have
 assigned<A href="glossary.html#routable"> routable</A> IP addresses, or
 they may be using private<A href="glossary.html#non-routable">
 non-routable</A> addresses (as defined in<A href="ftp://ftp.isi.edu/in-notes/rfc1918.txt">
 RFC 1918</A>) with the gateways doing<A href="glossary.html#masq"> IP
 masquerade</A>. It doesn't matter which, as long as whatever it is
 works correctly. Note, however, that the two client subnets must have
 distinct addresses. You cannot have them both masqueraded to the same
 range of RFC 1918 addresses.</P>
<P>You must have a working IP network before you try to add IPsec:</P>
<UL>
<LI>If Sunrise and Sunset have routable IP addresses, test that they can
 ping each other.</LI>
<LI>If IP masquerading is in use, test as far as you can. Even with
 masquerading on both ends, Sunset should be able to ping East and
 Sunrise able to ping West.</LI>
</UL>
<P>It is not enough to just test that your gateways (East and West in
 the example) can communicate. You need to test routing to the clients
 (Sunrise and Sunset) as well.</P>
<P>If you want to run some service encapsulated in IP -- perhaps to use
 Novell protocols encapsulated in IPX or to make Windows file sharing or
 NT domains work across the IPsec tunnel -- then<EM> please</EM> build
 and test what you need for that service on plain IP before trying it
 over IPsec. It can be a real nightmare trying to debug such things when
 you don't know if the problem is in IPsec, firewall rules, routing, or
 the configuration of the service itself. Some advice on making such
 things work with IPsec is in our<A href="interop.html#NTdomain">
 interoperation</A> section.</P>
<H3><A name="forward">Enabling packet forwarding</A></H3>
<P>Some systems turn off packet forwarding by default. This is the safe
 default. You don't want systems forwarding packets in uncontrolled
 ways.</P>
<P>There are three places where you can enable or disable IP forwarding:</P>
<DL>
<DT>in kernel configuration, before compiling the kernel</DT>
<DD>for FreeS/WAN use, forwarding must always be enabled here. If
 forwarding is not compiled into your kernel, attempts to enable or use
 it will fail.</DD>
<DT>in the standard boot scripts.</DT>
<DD>If your kernel has forwarding, you can have it turned on
 automatically by the standard boot scripts. The exact method varies
 from distribution to distribution:
<DL>
<DT>Older Redhat</DT>
<DD>in the file<VAR> /etc/sysconfig/network</VAR>, set<VAR>
 FORWARD_IPV4=yes</VAR></DD>
<DT>Redhat 6.x and 7.0</DT>
<DD>in the file<VAR> /etc/sysconfig/network</VAR>, set<VAR>
 net.ipv4.ip_forward=1</VAR></DD>
<DT>Debian r2.2 systems (and most likely Debian r2.2 derived systems):</DT>
<DD>in the file<VAR> /etc/network/options</VAR>, set<VAR> ip_forward=yes</VAR>
</DD>
</DL>
</DD>
<DT>From the command line or your own scripts</DT>
<DD>use the command:</DD>
<PRE>         echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward</PRE>
 You need root privileges to write to that file.</DL>
<P>A gateway machine needs forwarding enabled or it will not route
 packets between the two networks it is attached to. The simplest way to
 ensure this is to enable forwarding using your distribution's standard
 boot scripts. See above.</P>
<P>A more conservative approach is to disable forwarding in your system
 configuration, and only enable it after appropriate firewall rules and
 IPsec tunnels are in place. This reduces the risk of something slipping
 past your defenses before they are fully set up. On most systems, this
 can conveniently be done by adding a line to<VAR> /etc/rc.d/rc.local</VAR>
, which is usually the last script run at boot time.</P>
<H3><A name="othersoft">Other software</A></H3>
<P>Configure and test any other software you will want to use for
 testing once IPsec is up. For example, you might put an HTTP daemon on
 Sunset and a browser on Sunrise. Make sure these work without IPsec.</P>
<P>If these tests fail, figure out why and fix it.<STRONG> Do not
 proceed until it works.</STRONG></P>
<H2><A name="usersakey">Setting up RSA authentication keys</A></H2>
<P>To build a connection, the two gateway machines must be able to
 authenticate each other. For FreeS/WAN, the default is<A href="glossary.html#public">
 public key</A> authentication based on the<A href="glossary.html#RSA">
 RSA</A> algorithm. IPsec does allow several other authentication
 methods; using some of them with FreeS/WAN is discussed in our<A href="adv_config.html#choose">
 advanced configuration</A> section.</P>
<P>This section covers setting up RSA keys. The example connections to
 follow (VPN, road warrior and opportunistic) all use RSA.</P>
<H3><A name="rsa.basics">How RSA works</A></H3>
<P>RSA keys are created as matched pairs. Each pair includes:</P>
<UL>
<LI>a<STRONG> public key</STRONG> which need not be kept secure.
 Everyone you plan to communicate with must be able to get a copy of
 this. It does not matter if an enemy gets it as well.</LI>
<LI>a<STRONG> private key</STRONG> which must be kept secure. No-one but
 you should have access to it.</LI>
</UL>
<P>For FreeS/WAN, both keys for your system are in the<A href="manpage.d/ipsec.secrets.5.html">
 ipsec.secrets(5)</A> file.<STRONG> Maintaining security of this file is
 essential</STRONG> since it holds your private key.</P>
<P>Public keys for the gateways you communicate with must be made
 available to your gateway. There are several ways to do this:</P>
<UL>
<LI>arrange for the administrators of those gateways to place their
 public keys in their<A href="glossary.html#DNS"> DNS</A> records so
 your gateway can look them up as required</LI>
<LI>collect the public keys for the gateways you talk to, and place them
 in the connection descriptions for those gateways in<A href="manpage.d/ipsec.conf.5.html">
 ipsec.conf(5)</A>.</LI>
<LI>if you are using the X.509<A href="web.html#patch"> patches</A>,
 collect X.509 certificates for the other gateways, and place them in
 the appropriate file</LI>
</UL>
<P>The first two methods are described in more detail below. See the
 X.509 patch documentation for details of the third, if required.</P>
<P>Remember that public key systems are designed so that<STRONG> it does
 not matter if an enemy knows the public keys</STRONG>. However, the<STRONG>
 private keys must be scrupulously protected</STRONG>.</P>
<H3><A name="genrsakey">Generating an RSA key pair</A></H3>
<P>If you installed FreeS/WAN yourself, then the installation process
 has already generated an RSA key pair for you and placed it in the<A href="manpage.d/ipsec.secrets.5.html">
 ipsec.secrets(5)</A> file. If not, then you need to generate an RSA key
 pair (private and public).</P>
<P>If you have the common simple situation where:</P>
<UL>
<LI>the gateway needs only one RSA private key</LI>
<LI>the output of the<VAR> hostname</VAR> command is a suitable
 identifier</LI>
</UL>
<P>then you can just give these commands as root:</P>
<PRE>        ipsec newhostkey &gt; /etc/ipsec.secrets
        chmod 600 /etc/ipsec.secrets</PRE>
<P>For other options, for example if you want to use different
 identities with different partners, see the<A href="manpage.d/ipsec.secrets.5.html">
 ipsec.secrets(5)</A> and<A href="manpage.d/ipsec_newhostkey.8.html">
 ipsec_newhostkey(8)</A> man pages.</P>
<P>Key generation may take some time, even on a fast system. Also, it
 needs a lot of<A href="glossary.html#random"> random numbers</A> so you
 may need to switch consoles and do something like typing a lot of text
 or running<NOBR><VAR> du / &gt; /dev/null</VAR>. These give<VAR> random(4)</VAR>
 some inputs to work with.</P>
<P>The RSA keys we generate are suitable<STRONG> only</STRONG> for
 authentication, not for encryption. IPsec uses them only for
 authentication. See our<A href="ipsec.html"> IPsec</A> section for
 details.</P>
<P>It is also possible to use keys in other formats, not generated by
 FreeS/WAN. This may be necessary for interoperation with other IPsec
 implementations. See our links to<A href="web.html#patch"> patches</A>
 which add support for keys generated by PGP or embedded in X.509
 certificates.</P>
<H3><A name="keyexchange">Exchanging authentication keys</A></H3>
 Once your gateway's key is in<A href="manpage.d/ipsec.secrets.5.html">
 ipsec.secrets(5)</A>, the next step is to send your public key to
 everyone you need to set up connections with and collect their public
 keys. The other players will be:
<DL>
<DT>for a VPN</DT>
<DD>each gateway administrator needs public keys for all the other
 gateways his or her machine talks to</DD>
<DT>for a Road Warrior</DT>
<DD>the gateway needs public keys for all Warriors that connect to it,
 and each Warrior needs the gateway public key</DD>
<DT>for opportunistic encryption</DT>
<DD>no explicit key exchange is needed, but you must put your public key
 in DNS so others can find it when they need it</DD>
</DL>
<P>You need to extract the public part in a suitable suitable format.
 This done with the<A href="manpage.d/ipsec_showhostkey.8.html">
 ipsec_showhostkey(8)</A> command. For VPN or Road Warrior applications,
 use one of:</P>
<PRE>        ipsec showhostkey --left
        ipsec showhostkey --right</PRE>
<P>These two produce the key formatted for insertion in an<A href="manpage.d/ipsec.conf.5.html">
 ipsec.conf(5)</A> file.</P>
<P>For opportunistic encryption, just use:</P>
<PRE>        ipsec showhostkey</PRE>
 This gives the key in a format suitable for use in DNS records.
<P>Public keys need not be protected as fanatically as private keys.
 They are intended to be made public; the system is designed to work
 even if an enemy knows all the public keys used. You can safely make
 them publicly accessible -- for example, put a gateway key on a web
 page, make in available in DNS or via finger(1) -- or transmit it with
 an insecure method such as email. However, the recipient<EM> must</EM>
 be able to authenticate them, as described in the next section.</P>
<H3><A name="pub.auth">Authenticating public key exchange</A></H3>
 Authentication of public keys is critical. It does not matter if an
 enemy knows your public keys, but<STRONG> if you can be tricked into
 trusting a public key supplied by an enemy, you are in deep trouble</STRONG>
.
<P>For example, consider the fellow who wants to communicate with his
 mistress, keeping messages secret from his wife.</P>
<UL>
<LI>If the wife obtains the mistress' public key, that is not a problem.
 As long as she does not get the private key, she can neither read
 things sent to the mistress nor authenticate herself as the mistress.</LI>
<LI>If the mistress has any sense, she protects her private key
 carefully. So long as she does that, and the husband encrypts his
 messages correctly, there should be no (cryptographic!) problem.</LI>
<LI>Imagine that the wife is somewhat devious. She generates a
 public/private key pair and sends the husband that public key, forging
 the message to look as if it came from the mistress. Of course<EM> this
 fails if the husband has enough sense to check the key's validity</EM>
 before using it.</LI>
<LI>However, if the husband blindly<EM> accepts that key without
 verification</EM>, it is<EM> extremely</EM> unlikely that he will be
 pleased with the results.</LI>
<LI>If he accepts that key, the wife can read every message he sends to
 it. The mistress cannot.</LI>
<LI>The wife can also pose as the mistress and send him whatever bogus
 messages she likes. As long as he trusts that key, he will believe
 these came from the mistress.</LI>
</UL>
<P>The minute he begins to trust a bogus key, the cryptography does not
 just stop working for him. Instead, it becomes a powerful weapon
 against him.</P>
<P>You<STRONG> must authenticate any public keys received</STRONG>
 before using them. For remote sites, the simplest method is to exchange
 them using<A href="glossary.html#PGP"> PGP</A>-signed email (taking
 appropriate steps to authenticate the signing keys). Keys posted on the
 web or made available for finger(1) should also be PGP-signed. Keys in
 DNS should be protected by<A href="glossary.html#SDNS"> DNS Security</A>
. For nearby machines, a floppy disk or trusted network is fine.</P>
<H3><A name="useRSA">Using RSA signatures for authentication</A></H3>
<P>For each system you will communicate with, you need an RSA public key
 and an identifier associated with it. The identifiers go in the<VAR>
 leftid=</VAR> and<VAR> rightid=</VAR> lines of connection descriptions
 in<VAR> ipsec.conf(5)</VAR>. They are the names the systems use to
 identify themselves during connection negotiation.</P>
<P>The syntax rules allow four types of identifier:</P>
<UL>
<LI>an IP address in dotted quad notation, four numbers separated by
 periods (10.1.19.32).</LI>
<LI>a domain name, which will be resolved immediately (bad.example.com).</LI>
<LI>a fully qualified domain name (FQDN) with a leading &quot;@&quot; to indicate
 that it should not be resolved (@good.example.com)</LI>
<LI>user@FQDN (fred@example.com)</LI>
</UL>
<P><STRONG>We recommend that only the @FQDN form be used</STRONG> in
 most applications. The other three forms have problems:</P>
<UL>
<LI>IP addresses make remarkably uninteresting names</LI>
<LI>Resolving a name to an IP address is not useful. Why pay the
 overheads just to get something that, in this context, is less
 interesting than the name you started with? Also, the attempt to
 resolve it may cause long delays if DNS is down or may cause security
 problems if someone subverts a DNS server which you rely on.</LI>
<LI>fred@example.com has no advantage over @fred.example.com</LI>
</UL>
<P>If your domain is example.com, the gateway identifiers you use should
 be all be of the form &quot;@<VAR>something</VAR>.example.com&quot; with some
 convenient string replacing<VAR> something</VAR>.</P>
<P>In order to facilitate distributing keys through DNS, we recommend
 avoiding</P>
<UL>
<LI>names from non-existent domains</LI>
<LI>names from other people's domains</LI>
<LI>names which conflict with machine names in your domain</LI>
<LI>user@FQDN</LI>
</UL>
<P>For example, if you have a server alice.example.com, then you should
 not use &quot;@alice.example.com&quot; to identify Alice's laptop for IPsec.</P>
<P>One convenient scheme is to</P>
<DL>
<DT>use DNS names for your gateways</DT>
<DD>their IPsec identifiers are things like @firewall.example.com or
 @toronto.example.com</DD>
<DT>add a &quot;road&quot; label in the identifiers for your remote users (&quot;Road
 Warriors&quot;)</DT>
<DD>Alice's laptop uses the identifier @alice.road.example.com.</DD>
</DL>
<H2><A name="basic.conf">The configuration file</A></H2>
<P>FreeS/WAN uses a configuration file,<A href="manpage.d/ipsec.conf.5.html">
 ipsec.conf(5)</A>.</P>
 This section describes setting up the parts of that file that apply to
 all connections:
<DL>
<DT><VAR>config setup</VAR> section</DT>
<DD>describes machine configuration</DD>
<DT><VAR>conn default</VAR> section</DT>
<DD>default parameters which apply to all connections</DD>
</DL>
<P>and gives an introduction to the parts of the file that specify the
 actual connections. The following section covers setting up three
 common types of connection, all using automatic keying with RSA
 authentication of the gateways:</P>
<DL>
<DT>conventional VPN</DT>
<DD>two security gateways, each with a known fixed IP address and with a
 network of client machines behind it</DD>
<DT>Road Warrior</DT>
<DD>one player has a dynamically-assigned address</DD>
<DT>opportunistic encryption</DT>
<DD>the two machines have no prior knowledge of each other, but are set
 up to secure connections whenever possible</DD>
</DL>
<P>Setup is quite similar for each of these, but details differ.</P>
<P>Other types of connections are covered in later sections.</P>
<P>The easiest way to create a connection is by editing one of our
 examples. Here we will use the one in the installation<A href="manpage.d/ipsec.conf.5.html">
 ipsec.conf</A> file. You could also start with one from our<A href="examples">
 doc/examples</A> file if one of those is closer to what you need to do.</P>
<H3><A name="ipsec.conf.general">General comments on ipsec.conf</A></H3>
 The<A href="manpage.d/ipsec.conf.5.html"> ipsec.conf(5)</A> file is
 divided into sections, and the following rules apply:
<UL>
<LI>the '#' character marks a comment</LI>
<LI>the first uncommented line of a section must be at the margin, not
 indented</LI>
<LI>all other non-comment lines of a section must be indented</LI>
<LI>blank lines separate sections</LI>
<LI>you cannot put a blank line within a section; use a lone '#' instead</LI>
</UL>
<P>For more detail, see the<A href="manpage.d/ipsec.conf.5.html"> man
 page</A>.</P>
<H4><A name="which">Which is which?</A></H4>
<P>The confguration file uses<VAR> left</VAR> and<VAR> right</VAR> to
 refer to the two gateways involved in a connection, and has other
 parameters which come in left/right pairs. For example,<VAR> leftsubnet</VAR>
 is the subnet behind<VAR> left</VAR>.</P>
<P>Which gateway is<VAR> left</VAR> and which is<VAR> right</VAR> is
 arbitrary, entirely up to you.</P>
<P>We suggest that you name connections by their ends. For example, name
 the link between Fred and Susan's machines &quot;fred-susan&quot; or the link
 between your Reno and Vancouver offices &quot;reno-van&quot;. You can then let
 &quot;left&quot; refer to the left half of the name, &quot;fred&quot; or &quot;reno&quot; in our
 examples, and &quot;right&quot; to the other half.</P>
<P>To simplify administration, we recommend that you use the same names
 in the<VAR> ipsec.conf(5)</VAR> files on both ends. The name<VAR> reno</VAR>
, for example, should refer to the machine in Reno, no matter which city
 the file is in.</P>
<P>Then when you copy the file from one machine to the other, the<EM>
 only</EM> change you need to make on the second machine is changing the<VAR>
 interfaces=</VAR> line to match the interface that machine uses for
 IPsec.</P>
<P>Of course the software does not actually require this. The names are
 just arbitrary strings to it. If your administrator in Reno wants to
 refer to the machines as &quot;Phobos&quot; and &quot;Demios&quot; while the Vancouver
 admin calls them &quot;George&quot; and &quot;Gracie&quot;, things should still work.</P>
<H3><A name="setup.conf">The setup section of ipsec.conf(5)</A></H3>
<P>The first section of<A href="manpage.d/ipsec.conf.5.html">
 ipsec.conf(5)</A> contains overall setup parameters for IPsec, which
 apply to all connections. In our example file, it is:</P>
<PRE># basic configuration
config setup
        # THIS SETTING MUST BE CORRECT or almost nothing will work;
        # %defaultroute is okay for most simple cases.
        interfaces=%defaultroute
        # Debug-logging controls:  &quot;none&quot; for (almost) none, &quot;all&quot; for lots.
        klipsdebug=none
        plutodebug=none
        # Use auto= parameters in conn descriptions to control startup actions.
        plutoload=%search
        plutostart=%search
        # Close down old connection when new one using same ID shows up.
        uniqueids=yes</PRE>
<P>The variables set here are:</P>
<DL>
<DT>interfaces</DT>
<DD>Tells the<A href="glossary.html#KLIPS"> KLIPS</A> IPsec code in the
 Linux kernel which network interface to use. The interfaces specified
 here are the only ones this gateway machine will use to communicate
 with other IPsec gateways.<STRONG> If this is not correct, nothing
 works.</STRONG></DD>
<P>In many cases, the appropriate interface is just your default
 connection to the world (the Internet, or your corporate network). In
 these cases, you can use the default setting:</P>
<UL>
<LI>interfaces=%defaultroute</LI>
</UL>
<P>To check what FreeS/WAN sees as the default route, you can use the
 command<VAR> ipsec showdefaults</VAR>. You may need to compare this
 with the output from<VAR> route -n</VAR> to get a more complete
 picture.</P>
<P>In other cases, you can name one or more specific interfaces to be
 used by FreeS/WAN. For example:</P>
<UL>
<LI>interfaces=&quot;ipsec0=eth0&quot;</LI>
<LI>interfaces=&quot;ipsec0=eth0 ipsec1=ppp0&quot;</LI>
</UL>
<P>Both tell KLIPS to use eth0 as ipsec0. The second one also supports
 IPsec over PPP.</P>
<P>Note that</P>
<UL>
<LI>Multiple tunnels do not require multiple interfaces. It is possible,
 and even common, to have one ipsec interface carrying traffic for many
 tunnels.</LI>
<LI>For PPP connections, you specify the virtual PPP interface (for
 example<VAR> ppp0</VAR>) here,<STRONG> not</STRONG> the underlying
 physical interface.</LI>
</UL>
<P>If you need to discover interface names, use the command:</P>
<PRE>              ifconfig
      </PRE>
 If you have PCMCIA or other interfaces that are not available at boot
 time, special measures are required. See our<A href="adv_config.html#dynamic">
 section</A> on that.
<DT>klipsdebug</DT>
<DD>Debugging setting for the KLIPS kernel code</DD>
<DT>plutodebug</DT>
<DD>Debugging setting for the Pluto key and connection negotiation
 daemon.</DD>
<P><VAR>klipsdebug</VAR> and<VAR> plutodebug</VAR> can each be set to
 &quot;none&quot; or to &quot;all&quot; in most circumstances. There are other options; see
 the relevant man pages.</P>
<DT>plutoload</DT>
<DD>List of connections to be automatically loaded into memory when
 Pluto starts.</DD>
<DT>plutostart</DT>
<DD>List of connections to be automatically negotiated when Pluto
 starts.</DD>
<P><VAR>plutoload</VAR> and<VAR> plutostart</VAR> can be quoted lists of
 connection names, but are often set to<VAR> %search</VAR> as in our
 example. Any connection with<VAR> auto=add</VAR> in its connection
 definition is then loaded, and any connection with<VAR> auto=start</VAR>
 is started.</P>
<P>In most cases, you want<VAR> plutostart=%search</VAR> here and<VAR>
 auto=start</VAR> in your connection descriptions. That way when a
 connection is broken, for example if one machine crashes or is taken
 down for some reason, it will be reliably rebuilt. If only one end is
 told to start the connection, then if the other end crashes, you may
 lose the connection for a long time. The end that could rebuild does
 not know it needs to.</P>
<P>The exception to the above is when you have many road warriors
 connecting to a single gateway. Having the gateway trying to rebuild
 tunnels to systems which are offline can waste considerable resources.
 In this case, the gateway should have<VAR> auto=add</VAR> for all
 connections, and let the remote systems start negotiations.</P>
<DT>uniqueids</DT>
<DD>Controls whether two connections with the same subnet on the remote
 end are allowed. Normally this is set to<VAR> yes</VAR> so that when a
 remote system disconnects and reconnects, Pluto will automatically take
 the old connection down.</DD>
</DL>
<H3><A name="conn.default">Connection defaults</A></H3>
<P>There is a special name<VAR> %default</VAR> that lets you define
 things that apply to all connections.</P>
<P>You can also set general defaults here but override them later for
 specific connections. If both the<VAR> %default</VAR> section and the
 actual connection description set the same variable, then the
 connection description takes precedence.</P>
<P>Our example file has:</P>
<PRE># defaults for subsequent connection descriptions
conn %default
        # How persistent to be in (re)keying negotiations (0 means very).
        keyingtries=0
        # How to authenticate gateways
        authby=rsasig
        # Load all connection descriptions by default
        # Some will override this with auto=start
        auto=add</PRE>
<P>Variables set here are:</P>
<DL>
<DT>keyingtries</DT>
<DD>How persistent to be in (re)keying negotiations (0 means very).</DD>
<P>For testing, you might wish to set this to some small number, perhaps
 even to 1, to avoid wasting resources on incorrectly set up
 connections. In production, it is often set to zero (retry forever).
 Keeping the connection up is what machine resources are for, so if a
 connection is down you might as well waste resources retrying as waste
 them by sitting idle. Of course some caution should be exercised with
 this, since it can waste network resources as well.</P>
<DT>authby=rsasig</DT>
<DD>authenticate gateways using RSA signatures. This is the preferred
 method and is what we will use in this section's examples. An alternate
 method is to use<A href="adv_config.html#prodsecrets"> shared secrets</A>
.</DD>
<DT>auto=add</DT>
<DD><STRONG>auto</STRONG>matically<STRONG> add</STRONG> connections
 descriptions to Pluto's in-memory database at startup. This is required
 before Pluto can recognise incoming requests for that connection, so we
 suggest making it the default here.</DD>
<P>To actually start negotiations for a given connection, you need<VAR>
 auto=start</VAR>. You could make that the default here or leave<VAR>
 auto=add</VAR> as the default and override it where needed with<VAR>
 auto=start</VAR> in individual connection descriptions.</P>
</DL>
<P>Once you are finished testing, you can edit these defaults, adding
 anything that is standard for all gateways in your organisation.</P>
<H3><A name="edit.conn">Editing a connection description</A></H3>
<P>Edit our example connection to match what you want to do. Rename it
 appropriately for the connection you would like to build: &quot;fred-susan&quot;,
 &quot;reno-van&quot; or whatever. The name is the second string in the line that
 begins with &quot;conn&quot;, for example in:</P>
<PRE>        conn snt</PRE>
<P>The connection name is &quot;snt&quot; (<STRONG>s</STRONG>ub<STRONG>n</STRONG>
et<STRONG> t</STRONG>unnel) and to define another connection you make a
 copy with a new name such as:</P>
<PRE>        conn reno-van</PRE>
<P>A sample connection description is:</P>
<PRE># sample tunnel
# The network here looks like:
#   leftsubnet====left----leftnexthop......rightnexthop----right====rightsubnet
# If left and right are on the same Ethernet, omit leftnexthop and rightnexthop.
conn sample
        # left security gateway (public-network address)
        left=10.0.0.1
        # next hop to reach right
        leftnexthop=10.44.55.66
        # subnet behind left (omit if there is no subnet)
        leftsubnet=172.16.0.0/24
        # right s.g., subnet behind it, and next hop to reach left
        right=10.12.12.1
        rightnexthop=10.88.77.66
        rightsubnet=192.168.0.0/24
        auto=start</PRE>
<P>We omit here the variables we have shown as set in the default
 connection above. All of them could also be set here. If they are set
 in both places, settings here take precedence. Defaults are used only
 if the specific connection description has no value set.</P>
<P>The network described above looks like this:</P>
<PRE>         subnet 172.16.0.0/24              =leftsubnet
                |
                |                          [whatever]
                |
         inside interface
            left gateway machine
         interface 10.0.0.1                =left
                 |
         interface 10.44.55.66             =leftnexthop
              router
         interface we don't know
                 |
            INTERNET
                 |
         interface we don't know
              router
         interface 10.88.77.66             =rightnexthop
                 |
         interface 10.12.12.1              =right
            right gateway machine
         inside interface
                 |
                 |                         [whatever]
                 |
         subnet 192.168.0.0/24             =rightsubnet</PRE>
 You need to edit the connection description, inserting appropriate IP
 addresses and subnet descriptions so that it describes your network.
<P>The [whatever]s above indicate places where all that matters is
 routing.</P>
<UL>
<LI>in simple cases, the inside interface is directly connected to the
 protected subnet and has an address on that subnet</LI>
<LI>in a large organisation, there might be several routers between
 gateway and subnet</LI>
</UL>
 It does not matter what is between the inside interface and the
 protected subnet, as long as the gateway knows how to get packets to
 the subnet.
<P>You do not need to tell FreeS/WAN anything about the inside
 interfaces. In fact, there is no parameter you could use to do that.
 What you do have to do is make sure the gateway can route to its client
 subnet.</P>
<P>In most cases, you should use numeric IP addresses, not names, here.
 The file syntax allows names to be used, but this creates an additional
 risk. If someone can subvert the DNS service, then they can redirect
 packets whose addresses are looked up via that service.</P>
<P>Many of the variables in this file come in pairs such as &quot;leftsubnet:
 and &quot;rightsubnet&quot;, one for each end of the connection. The variables on
 the left side are:</P>
<DL>
<DT>left</DT>
<DD>The gateway's external interface, the one it uses to talk to the
 other gateway. This can be<VAR> left=%defaultroute</VAR>.</DD>
<DT>leftnexthop</DT>
<DD>Where left should send packets whose destination is right, typically
 the first router in the appropriate direction.</DD>
<P>This need not always be set.</P>
<UL>
<LI>If the two gateways are directly linked (packets can go from one to
 the other without IP routing by any intermediate device) then you need
 not set either<VAR> leftnexthop</VAR> or<VAR> rightnexthop</VAR>.</LI>
<LI>a connection with<VAR> left=%defaultroute</VAR> or<VAR>
 right=%defaultroute</VAR> must not have the corresponding<VAR> nexthop</VAR>
 parameter set</LI>
</UL>
<P>However,<STRONG> in all other cases, you must provide nexthop
 information</STRONG>. KLIPS (Kernel IP Security) bypasses the normal
 routing machinery, so you must give KLIPS the information even though
 routing already knows it.</P>
<P>(Yes, we know that design is not ideal, and we plan to change it. See
 extensive discussions on the<A href="mail.html"> mailing list</A>,
 mostly with &quot;routing&quot; or &quot;KLIPS 2&quot; in the subject lines.)</P>
<DT>leftsubnet</DT>
<DD>Addresses for the machines which left is protecting.
<UL>
<LI>Often something like 101.202.203.0/24 to indicate that a subnet
 resides behind left. Often this subnet will be directly connected to
 left, but this not necessary. The only requirement is that left must be
 able to route to it.</LI>
<LI>If you omit the leftsubnet line, then left is both the security
 gateway and the only client on that end.</LI>
</UL>
 For some applications, you may want to create two connections, one to
 protect traffic from the subnet behind left and another to protect
 traffic from the left gateway itself. This takes two connection
 descriptions. See<A href="adv_config.html#multitunnel"> below</A>.</DD>
<DT>auto</DT>
<DD>If the<VAR> conn setup</VAR> section has<VAR> plutoload=%search</VAR>
, then all connections marked<VAR> auto=add</VAR> are loaded when Pluto
 starts.</DD>
<P>If the<VAR> conn setup</VAR> section has<VAR> plutostart=%search</VAR>
, then all connections marked<VAR> auto=start</VAR> are started when
 Pluto starts.</P>
<P>Initially, we suggest using<VAR> auto=add</VAR> on all connections.
 This lets you start them manually during testing. Once they are tested,
 you can change many of them to<VAR> auto=start</VAR>.</P>
</DL>
<P>For each left* parameter, there is a corresponding right* parameter.</P>
<P>Note that<EM> a connection to a subnet behind left does not include
 left itself</EM>. The tunnel described above protects packets going<EM>
 from one subnet to the other</EM>. It does not apply to packets which
 either begin or end their journey on one of the gateways. If you need
 to protect those packets, you must build separate tunnel descriptions
 for them.</P>
<P>It is a common error to attempt testing a subnet-to-subnet connection
 by pinging from one of the gateways to the far end or vice versa.<STRONG>
 This does not work</STRONG>, even if the connection is functioning
 perfectly, because<EM> traffic to or from the gateway itself is not
 sent on that connection</EM>. If you want to protect traffic
 originating or terminating on the gateway, then you need a separate
 tunnel for that in addition to the subnet's tunnel. See the section on<A
href="adv_config.html#multitunnel"> multiple tunnels</A>.</P>
<H2><A name="examples">Example setups</A></H2>
<P>In this section we show examples of three common setups:</P>
<UL>
<LI>a VPN connection</LI>
<LI>road warrior support</LI>
<LI>opportunistic encryption</LI>
</UL>
<P>We use a, b, c ... to indicate components of IP addresses. Each
 letter is some number in the range 0 to 255, inclusive.</P>
<P>For additional examples, see our<A href="examples"> examples</A>
 file.</P>
<H3><A name="VPNex">VPN</A></H3>
 For a site-to-site VPN, a simple network diagram looks like this:
<PRE>        Sunset==========West------------------East=========Sunrise
              local net       untrusted net       local net</PRE>
<P>which we describe in our config files as:</P>
<PRE>     leftsubnet === West------------------East=== rightsubnet
                        ^left       right^ </PRE>
<P>In most cases, we also have to provide next hop information. A more
 detailed diagram might look like this:
<BR> (using a, b, c, ... to refer to arbitrary numbers 0 to 255)</P>
<PRE>         subnet a.b.c.0/24                 =leftsubnet
                |          (head office has routable IP addresses)
         interface a.b.c.d
            left gateway machine
         interface e.f.g.h                 =left
                 |         (external address outside a.b.c.0 subnet)
         interface e.f.g.i                 =leftnexthop
              router
         interface we don't know
                 |
            INTERNET
                 |
         interface we don't know
              router
         interface j.k.l.m                =rightnexthop
                 |
         interface j.k.l.n                =right
            right gateway machine
         interface 192.168.0.something
                 |        (branch office uses private IP addresses)
         subnet 192.168.0.0/24             =rightsubnet</PRE>
<P>The<A href="manpage.d/ipsec.conf.5.html"> ipsec.conf(5)</A> file for
 the above network would look like this (with RSA keys shortened for
 easy display):</P>
<PRE># basic configuration
config setup
        interfaces=&quot;%defaultroute&quot;
        klipsdebug=none
        plutodebug=none
        plutoload=%search
        plutostart=%search

# defaults that apply to all connection descriptions
conn %default
        # How persistent to be in (re)keying negotiations (0 means very).
        keyingtries=0
        # How to authenticate gatways
        authby=rsasig

# VPN connection for head office and branch office
conn head-branch
        # identity we use in authentication exchanges
        leftid=@head.example.com
        leftrsasigkey=0x175cffc641f...
        # left security gateway (public-network address)
        left=e.f.g.h
        # next hop to reach right
        leftnexthop=e.f.g.i
        # subnet behind left (omit if there is no subnet)
        leftsubnet=a.b.c.0/24
        # right s.g., subnet behind it, and next hop to reach left
        rightid=@branch.example.com
        rightrsasigkey=0xfc641fd6d9a24...
        right=j.k.l.n
        rightnexthop=j.k.l.m
        rightsubnet=192.168.0.0/24
        #
        # right is masquerading
        # So you have three choices, none of them ideal
        #
        # uncomment this to use our default script
        # which works only with ipfwadm(8) on 2.0 kernels
        # or ipchains(8) on 2.2 in ipfwadm(8) emulation mode
        # rightfirewall=yes
        #
        # uncomment this and enter a name to write your own script
        # to use all features of ipchains(8) on 2.2
        # or to use iptables(8) on 2.4
        # rightupdown=whatever_you_want_to_name_the_script
        #
        # if you uncomment neither and remove the rightsubnet= line
        # then the tunnel terminates on the outside of your gateway
        # and the masqueraded subnet is not visible to the remote
        # subnet; they all think they're talking to the gateway
        #
        # try to start the connection
        auto=start</PRE>
<P>For more on the use of the firewalling parameters --<VAR>
 leftfirewall</VAR>,<VAR> rightfirewall</VAR>,<VAR> leftupdown</VAR> and<VAR>
 rightupdown</VAR> -- see our<A href="firewall.html"> IPsec and
 firewalls</A> section.</P>
<P>The versions of this file at the two ends should be identical, except
 that each must have an<VAR> interfaces=</VAR> line appropriate for the
 local machine.</P>
<H4><A name="route_or_not">Routable and non-routable addresses</A></H4>
<P>RFC 1918 reserves three groups of addresses for use on private
 networks:</P>
<UL>
<LI>10.0.0.0/8</LI>
<LI>172.16.0.0/12</LI>
<LI>192.168.0.0/16</LI>
</UL>
<P>Addresses in these ranges will never be assigned to anything on the
 Internet. Many routers automatically drop any packet with one of these
 addresses as either source or destination.</P>
<P>You can use FreeS/WAN to:</P>
<UL>
<LI>make such a network visible to remote clients. For example, with the
 above description, any of the client machines on the<VAR> leftsubnet</VAR>
 can talk to machines on<VAR> rightsubnet=192.168.0.0/24</VAR>.</LI>
<LI>route between two such networks, using for example<VAR>
 leftsubnet=192.168.1.0/24</VAR> and<VAR> rightsubnet=192.168.0.0/24</VAR>
.</LI>
</UL>
<P>If you do this, the non-routable addresses still do not appear on the
 Internet. They are encapsulated inside IPsec packets which have the
 gateways' external addresses (from the<VAR> left</VAR> and<VAR> right</VAR>
 parameters of the connection description) in their headers.</P>
<P>Of course FreeS/WAN can also tunnel packets between subnets with
 normal routable IP address.</P>
<H3><A name="roadex">Road Warrior</A></H3>
<P>For our purposes, a &quot;road warrior&quot; is any machine that does not have
 a fixed IP address. This includes:</P>
<UL>
<LI>a traveller who might connect from anywhere</LI>
<LI>any machine that has a dynamic IP address -- nearly all dialup
 connections and most DSL or cable modem connections, at least in North
 America</LI>
<LI>most home machines connecting to the office. If you have a home
 firewall that is always left on and has a static IP address, then you
 can use the<A href="#VPNex"> VPN</A> configuration described above.
 Otherwise, consider yourself a road warrior.</LI>
</UL>
<P>The configuration for road warrior support looks slightly different
 from a VPN configuration. We cannot use the road warrior's IP address
 in the configuration file since we don't know it, and we don't want to
 have our server retrying connections to road warriors that are no
 longer online.</P>
<P>Some machines, such as home firewalls, may have a dynamic IP address
 and have a protected subnet behind them. For this example, however, we
 assume the Road Warrior is a standalone machine:</P>
<PRE>                                           telecommuter's PC or
                                           traveller's laptop
     Sunset==========West------------------East
         corporate LAN     untrusted net</PRE>
<P>In more detail, the network looks like this:
<BR> (using a, b, c, ... to refer to arbitrary numbers 0 to 255)</P>
<PRE>         subnet a.b.c.0/24               =leftsubnet
                |          (head office has routable IP addresses)
         interface a.b.c.d
            left gateway machine
         interface e.f.g.h               =left
                 |         (external address outside a.b.c.0 subnet)
         interface e.f.g.i               =leftnexthop
              router
                 |
            INTERNET
                 |
     interface with dynamic IP address
          road warrior machine</PRE>
<P>Here the<A href="manpage.d/ipsec.conf.5.html"> ipsec.conf(5)</A>
 files on the two ends are slightly different. The one at the office
 might have exactly the same<VAR> config setup</VAR> and<VAR> conn
 %default</VAR> sections as in the VPN example.</P>
<PRE># basic configuration
config setup
        interfaces=&quot;%defaultroute&quot;
        klipsdebug=none
        plutodebug=none
        plutoload=%search
        plutostart=%search

# defaults that apply to all connection descriptions
conn %default
        # How persistent to be in (re)keying negotiations (0 means very).
        keyingtries=0
        # How to authenticate gatways
        authby=rsasig</PRE>
<P>Then add a description for the road warrior connection:</P>
<PRE># Connection for road warrior Fred 
conn head-fred
        # identity we use in authentication exchanges
        leftid=@head.example.com
        leftrsasigkey=0x175cffc641f...
        # left security gateway (public-network address)
        left=e.f.g.h
        # next hop to reach right
        leftnexthop=e.f.g.i
        # subnet behind left (omit if there is no subnet)
        leftsubnet=a.b.c.0/24
        # accept any address for right
        right=%any
        # any address, provided authentication works
        rightid=@fred.road.example.com
        rightrsasigkey=0xd9a24765fe...
        #
        # no subnet for a typical road warrior
        # it is possible, but usually not needed
        # so the rightsubnet= parameter is omitted
        #
        # let the road warrior start the connection
        auto=add
        # override the default retry for road warriors
        # we don't want to retry if IP connectivity is gone
        keyingtries=1</PRE>
<P>On the gateway end we use the values shown above:</P>
<UL>
<LI><VAR>right=%any</VAR> so we have no preset idea of right's IP
 address and will accept whatever arrives on the packets</LI>
<LI><VAR>auto=add</VAR> so we accept connections but don't initiate</LI>
<LI><VAR>keyingtries=1</VAR> so we do not retry to excess when the
 partner disconnects or changes IP address</LI>
</UL>
<P>The file on the road warrior end is nearly identical, except that it
 has:</P>
<UL>
<LI><VAR>interfaces=%defaultroute</VAR> to handle the dynamic IP
 address.</LI>
<LI><VAR>right=%defaultroute</VAR></LI>
<LI><VAR>auto=start</VAR> to start the connection</LI>
<LI><VAR>keyingtries=0</VAR> to try to maintain the connection</LI>
</UL>
<P>Because we are using<VAR> right=%defaultroute</VAR>, we omit the<VAR>
 rightnexthop</VAR> parameter.</P>
<P>Additional road warriors can be added as required. Each should have
 his or her own connection description with unique settings for<VAR>
 rightid</VAR> and<VAR> rightrsasigkey</VAR>.</P>
<P>If necessary, a single road warrior can have multiple connections,
 all with the same<VAR> rightid</VAR> and<VAR> rightrsasigkey</VAR>, but
 with different values for<VAR> leftsubnet</VAR> to give access to
 different parts of the office network.</P>
<P>Jean-Francois Nadeau's<A href="http://jixen.tripod.com/#Rw-Fwan-to-Fwan">
 Practical Configurations</A> document also has an example of using RSA
 authentication for road warriors.</P>
<H3><A name="oppex">Opportunistic encryption</A></H3>
 We use the term<A href="glossary.html"> opportunistic encryption</A>
 for encryption which does not rely on any pre-arranged connection,
 hence does not require that the administrators of the two gateways
 involved communicate with each other (for example, to exchange keys)
 before their systems can create a secure connection.
<P>The idea is that each gateway check the destinations of outgoing
 packets, see if an encrypted connection is possible and, if so, take
 the opportuntity to encrypt. The opportunity will exist whenever the
 admins on both ends have set their systems up for opportunistic
 encryption.</P>
<P>This makes encryption the default behaviour, and could greatly
 increase the overall security of the Internet if it were widely enough
 adopted. See our documents:</P>
<DL>
<DT><A href="politics.html">history and politics</A></DT>
<DD>for the reasons we want to do this</DD>
<DT><A href="ipsec.html#traffic.resist">IPsec protocols</A></DT>
<DD>for discussion of the general principle of encrypting as much as
 possible</DD>
</DL>
<P>The gateways must be able to authenticate each other for IPsec to be
 secure. For opportunistic encryption, we rely on the domain name
 system,<A href="glossary.html"> DNS</A>, to provide the RSA keys needed
 for this authentication. Note, that currently this is not entirely
 secure because<STRONG> the DNS mechanism it relies on is not fully
 secure</STRONG>. Eventually, as<A href="glossary.html#SDNS"> secure DNS</A>
 becomes widely deployed, this will change.</P>
<H4><A name="opp.status">Status</A></H4>
 The team have been working on this for some time, and testing
 internally. The code is now ready for wider testing. We encourage
 everyone to try it.
<P>The main documentation items so far are:</P>
<UL>
<LI>an<A href="opportunism.howto"> Opportunism HowTo</A> by Pluto
 programmer Hugh Redelmeier</LI>
<LI>the project's internal<A href="opportunism.spec"> opportunism design
 document</A> by Hugh and technical lead Henry Spencer.</LI>
<LI>an<A href="http://www.ietf.org/internet-drafts/draft-richardson-ipsec-opportunistic-02.txt">
 Internet Draft</A> by Michael Richardson, Hugh and Henry. This is
 largely a rewrite of the internal document, a first step toward getting
 the protocol standardised so there can be multiple implementations of
 it.</LI>
</UL>
 I am playing catch up. HTML documentation so far is neither complete
 nor particularly clear. What I have so far is below.
<P><STRONG>We do not yet recommend this code for production use</STRONG>
. You should still protect your critical data with explicitly configured
 IPsec tunnels, rather than relying on opportunistic for everything at
 this stage.</P>
<H4><A name="opp.config">ipsec.conf entries for opportunism</A></H4>
<P>The relevant lines in the config file might look like this:</P>
<PRE>conn subnet-to-anyone              # for our client subnet
        leftsubnet=10.42.42.0/24   # any single client in our subnet
        left=%defaultroute         # our SG (defaults leftnexthop too)
        right=%opportunistic       # anyone we can authenticate via DNS
        rekey=no                   # let unused connections die</PRE>
<P>The public key, in our format, must be in a KEY record of the
 appropriate DNS entry for this to work. We provide some<A href="background.html#dns.background">
 background information</A> on DNS in another file.</P>
<P>Each opportunistic connection supports a single source/destination
 pair of IP addresses. There is no way to build an opportunistic
 connection for a larger subnet. Specifying a subnet in the connection
 description, as in the example above, just means that any host in that
 subnet may have opportunistic connections.</P>
<H4><A name="dnskey">Putting IPsec information in DNS</A></H4>
 To set up for opportunistic encryption, you add some KEY and TXT
 records to your DNS data. Specifically:
<UL>
<LI>each gateway must have a KEY record which other gateways can query
 to fetch its RSA authentication key</LI>
<LI>any client whose communications are to be protected by a gateway
 must have a TXT record pointing to that machine as an authorised IPsec
 gateway</LI>
</UL>
<A href="manpage.d/ipsec_showhostkey.8.html"> ipsec_showhostkey(8)</A>
 provides the key in DNS record format. You will need to put it in the
 appropriate place in the DNS records.
<P>To be more precise, quoting the Opportunism Design document:</P>
<PRE>For reference, the minimum set of DNS records needed to make
this all work is either:

1.  TXT in Destination reverse  map,  identifying  Responder
    and providing public key.
2.  KEY in Initiator reverse map, providing public key.
3.  TXT  in  Source  reverse  map, verifying relationship to
    Initiator.

or:

1.  TXT in Destination reverse map, identifying Responder.
2.  KEY in Responder reverse map, providing public key.
3.  KEY in Initiator reverse map, providing public key.
4.  TXT in Source reverse  map,  verifying  relationship  to
    Initiator.

Slight  complications  ensue  for dynamic addresses, lack of
control over reverse maps, etc.</PRE>
<H5><A name="dns.client">DNS records for client systems</A></H5>
 You must have control of the reverse maps for your client systems, or
 opportunistic IPsec cannot be made to work.
<P>The client systems will be either Source or Destination, so they must
 have:</P>
<PRE>1.  TXT in Destination reverse  map,  identifying  Responder
    and providing public key.
2.  ...
3.  TXT  in  Source  reverse  map, verifying relationship to
    Initiator.

or:

1.  TXT in Destination reverse map, identifying Responder.
2.  ...
3.  ...
4.  TXT in Source reverse  map,  verifying  relationship  to
    Initiator.</PRE>
 If you control the gateway's reverse map, example client records would
 look like this:
<PRE>42.42.42.10.in-addr.arpa. IN PTR deepthought.example.com.
42.42.42.10.in-addr.arpa. IN TXT &quot;X-IPsec-Server(10)=10.20.30.40 AQNJjkKlIk9...nYyUkKK8&quot;</PRE>
 which can also be written as just:
<PRE>42.42.42.10.in-addr.arpa. IN PTR deepthought.example.com.
                          IN TXT &quot;X-IPsec-Server(10)=10.20.30.40 AQNJjkKlIk9...nYyUkKK8&quot;</PRE>
 This provides the IP address of the security gateway and the public key
 which the gateway will use to authenticate itself. This is the
 preferred method.
<H5><A name="dns.gateway">DNS records for gateway systems</A></H5>
 The gateways will be either Initiator or Responder so they need:
<PRE>1.  ...
2.  KEY in Initiator reverse map, providing public key.
3.  ...

or:

1.  ...
2.  KEY in Responder reverse map, providing public key.
3.  KEY in Initiator reverse map, providing public key.
4.  ...</PRE>
<P>If you control the gateway's reverse map, you just add a KEY record
 there. That is all the gateway reverse map needs, whether it is working
 as Initiator or Responder.</P>
<P>Here is an example, with many characters of the key itself left out:</P>
<PRE>40.30.20.10.in-addr.arpa. IN KEY 0x4200 4 1 AQNJjkKlIk9...nYyUkKK8</PRE>
 This allows lookups on the IP address of the gateway to retrieve the
 key.
<H6>If you<EM> don't</EM> control the gateway's reverse map</H6>
 The approach must be different if you do not have control over the
 reverse map for your gateway. Perhaps your ISP controls that, and
 provides no way for you to put data into their maps. Without that, you
 cannot set your gateway up to respond to incoming opportunistic
 requests (short of changing ISPs, which you might consider).
<P>However, suppose a friend over at example.org will let you put things
 in their maps. That will allow you to set your gateway up to handle
 opportunistic connections for which it is the initiator.</P>
<P>You still need to be able to put data in the reverse map for your
 clients. However, that data is slightly different:</P>
<PRE>42.42.42.10.in-addr.arpa. IN PTR deepthought.example.com.
                          IN TXT &quot;X-IPsec-Server(10)=something.example.org&quot;</PRE>
 Over at example.org, your friend puts these lines in the DNS data
 files:
<PRE>something.example.org. IN A 10.20.30.40
something.example.org. IN KEY 0x4200 4 1 AQNJjkKlIk9...nYyUkKK8</PRE>
 Your gateway must identify itself in IKE as something.example.org, not
 as gateway.example.com. You set that up via<VAR> leftid=</VAR> or<VAR>
 rightid=</VAR> entries in<A href="manpage.d/ipsec.conf.5.html">
 ipsec.conf(5)</A>.
<P>With this arrangement, the remote gateway receives an ID payload
 early in IKE with your (bogus) gateway name &quot;something.example.org&quot;.
 Then it looks up that name to get the IP address and key for the
 gateway.</P>
<H2><A name="config.fancy">Going beyond the examples</A></H2>
 The examples above each described a single connection. This section
 discusses some issues in going beyond that, dealing with more
 complicated networks.
<P>If your network is simple enough that one of the examples had all you
 need, then you can skip ahead to<A href="#fw.basic"> firewall setup</A>
.</P>
<H3><A name="handy">Simplifying ipsec.conf files</A></H3>
<P>We provide several features in the syntax of the<A href="manpage.d/ipsec.conf.5.html">
 ipsec.conf(5)</A> file that are intended to simplify the work of
 managing complex multi-connection setups:</P>
<UL>
<LI>a<VAR> conn %default</VAR> connection description for information
 common to all connections</LI>
<LI><VAR>also=</VAR> lines allow a piece of a description to be defined
 in one place and used in several (the definition must be after all
 references)</LI>
<LI><VAR>include</VAR> directives allow information to be stored in
 separate files but used as part of the configuration</LI>
</UL>
<P>These can be combined in whatever way suits your application. One
 example is this ipsec.conf file for a gateway supporting multiple road
 warriors, all using RSA authentication:</P>
<PRE>conn %default
        type=tunnel
        pfs=yes
        keylife=2h
        # set some defaults appropriate for the gateway
        # these should be changed or overridden on the road warriors 
        keyingtries=1                   # road warrior can retry, we shouldn't
        auto=add                        # default is to load, but not start
        # some parameters are common to all remote systems
        authby=rsasig                   # all connections use RSA authentication
        right=%any                      # accept from any address

# pick up all remote system descriptions
# uses shell wildcards
include /etc/ipsec/remote.*.conn

# left side of all connections is the same
# define it after the descriptions which use it
conn leftstuff
        # left security gateway (public-network address)
        left=e.f.g.h
        # next hop to reach right
        leftnexthop=e.f.g.i
        # subnet behind left (omit if there is no subnet)
        leftsubnet=a.b.c.0/24
        leftid=@gateway.example.org</PRE>
<P>On the left gateway, we can omit<VAR> leftrsasig</VAR>. That gateway
 uses the private key stored in<A href="manpage.d/ipsec.secrets.5.html">
 ipsec.secrets(5)</A> and has no need for its own public key. Similarly,
 the road warriors need not have their own public keys in ipsec.conf(5),
 only the gateway's public key.</P>
<P>The remote connection descriptions in<VAR> /etc/ipsec/remote.*.conn</VAR>
 need then have only a few lines each:</P>
<PRE>conn myname
        # pick up common info for all connections
        also=leftstuff
        # identify the remote machine
        rightid=@myname.example.org
        rightrsasigkey=0xfc641fd6d9a24...</PRE>
<P>Be careful with the order of sections in ipsec.conf(5) and any
 included files. The parser requires that a definition comes after the<VAR>
 also=</VAR> line which uses it. In our example, the<VAR> include</VAR>
 inserts the files with the<VAR> also=leftstuff</VAR> lines before the
 definition of<VAR> conn leftstuff</VAR> so things are parsed in the
 correct order.</P>
<P>The above method, using<VAR> conn leftstuff</VAR> and<VAR> also=</VAR>
, is only one alternative. In simple cases, you can just put all the
 information about the left gateway in the<VAR> conn default</VAR>
 section instead and use no<VAR> also=</VAR> lines.</P>
<H2><A name="fw.basic">Is there a firewall in play?</A></H2>
<P>If firewall packet filtering is being done on either of the FreeS/WAN
 gateway machines, or on any machine on the path between them, then you
 will probably need to adjust the filters before FreeS/WAN can work. The
 filters must allow:</P>
<UL>
<LI>UDP packets between port 500 on one gateway and port 500 on the
 other, used by the automatic keying daemon Pluto.</LI>
<LI>at least one of protocol 50 (ESP) and 51 (AH). Most applications
 want ESP since AH does only authentication, not encryption.</LI>
</UL>
<P>For more detail, see our<A href="firewall.html"> IPsec and firewalls</A>
 document.</P>
<H2><A name="testing">Testing the installation</A></H2>
<P>This section covers testing connections once you have FreeS/WAN
 installed and your<A href="manpage.d/ipsec.conf.5.html"> ipsec.conf(5)</A>
 file set up. A separate<A href="testing.html"> testing document</A> has
 more information if required.</P>
<P>We assume all your connection descriptions use<VAR> auto=add</VAR> so
 that<A href="manpage.d/ipsec_pluto.8.html"> ipsec_pluto(8)</A> loads
 the descriptions into its internal database at startup but does not
 attempt to start the connections until you tell it to.</P>
<H3><A name="matching">Matching numbers</A></H3>
<P>It is important that the numbers in your connection descriptions
 match the network configuration. FreeS/WAN is almost certain to fail if
 they do not.</P>
<P>Suppose you are at the Reno office and your ipsec.conf file now has,
 among others, these lines:</P>
<PRE>config setup
        interfaces=&quot;ipsec0=eth0&quot;

conn reno-van
        left=101.101.101.101
        right=202.202.202.202</PRE>
<P>When you tell FreeS/WAN to start the reno-van connection, it doesn't
 automagically know that it is in Reno, or that it is<VAR> left</VAR> in
 the configuration. It discovers that by comparing the IP address for
 ipsec0 (and, if it is set, for ipsec1) to the addresses for left and
 right. ipsec0 inherits its address from the underlying device, eth0 in
 our example.</P>
<P>So in our example, if eth0 has IP address 101.101.101.101 then ipsec0
 inherits that address, the correct match is found, and this FreeS/WAN
 discovers that it is<VAR> left</VAR>. (If no match is found,<A href="manpage.d/ipsec_pluto.8.html">
 Pluto</A> reports &quot;unable to orient connection&quot;.) It then sets itself
 up with any other left* parameters in use -- some of<VAR> leftnexthop</VAR>
,<VAR> leftsubnet</VAR>, and<VAR> leftid</VAR>.</P>
<P>Once it has these parameters, FreeS/WAN sets things so that</P>
<UL>
<LI>packets from leftsubnet addressed to rightsubnet are routed through
 a tunnel to right.</LI>
<LI>packets for leftsubnet can be received on the tunnel and delivered.</LI>
</UL>
<P>All should be well.</P>
<P>Of course, there must also be interfaces and routes set up so that
 this machine can exchange IP packets both with the right gateway and
 with clients on leftsubnet. This is done with standard Linux utilities
 such as<VAR> ifconfig(8)</VAR> and<VAR> route(8)</VAR>. Also, things
 must be correct on right in Vancouver. It takes two to tunnel.</P>
<P>A data mismatch anywhere in this configuration will cause FreeS/WAN
 to fail and to log various error messages. Depending on just how
 confused FreeS/WAN is and about what, the error messages may be
 somewhat confusing. See our<A href="trouble.html"> troubleshooting</A>
 section and the FAQ section om<A href="faq.html#error"> error messages</A>
 to get help interpreting them if required.</P>
<P><EM>We recommend double-checking for consistency here before starting
 actual tests.</EM>.</P>
<H3><A name="testsetup">Sanity checking</A></H3>
<P>Reboot both gateways to get FreeS/WAN started. No connections are
 actually made yet, but the stage is set.</P>
<P>Examine<VAR> /var/log/messages</VAR> for any signs of trouble.</P>
<P>On both gateways, the following entries should now exist in the<VAR>
 /proc/net/</VAR> directory:</P>
<UL>
<LI>ipsec_eroute</LI>
<LI>ipsec_spi</LI>
<LI>ipsec_spigrp</LI>
<LI>ipsec_spinew</LI>
<LI>ipsec_tncfg</LI>
<LI>ipsec_version</LI>
</UL>
<P>and the IPsec interfaces should be attached on top of the specified
 physical interfaces. Confirm that with:</P>
<PRE>        cat /proc/net/ipsec_tncfg</PRE>
<P>You should see at least device<VAR> ipsec0</VAR>, and each ipsec
 device should point to a physical device, eg. 'ipsec0 -&gt; eth0 mtu=16260
 -&gt; 1500'.</P>
<P>Routing connections through these ipsec pseudo-devices causes the
 data to be encrypted before being delivered to the underlying network
 interface. This can be done manually with our<A href="manpage.d/ipsec_eroute.8.html">
 eroute(8)</A> utility, but in most cases you do not need to use that
 utility directly. Just bring the connections up and down and the
 scripts call it as required.</P>
<P>Don't be surprised when you cannot find<VAR> /dev/ipsec0</VAR> or<VAR>
 /dev/ipsec1</VAR>. They do not exist. Other network pseudo-devices such
 as<VAR> eth0</VAR> and<VAR> eth1</VAR> do not have entries in<VAR> /dev</VAR>
 either. In general, network devices do not need such entries.</P>
<H3><A name="test">Starting a connection</A></H3>
<P>On one gateway, start IPsec with:</P>
<PRE>        ipsec auto --up <VAR>name</VAR></PRE>
<P>replacing<VAR> name</VAR> with the connection name you used in
 ipsec.conf(5).</P>
<P>For this to work, the connection description must already be loaded
 into Pluto's database, either via<VAR> auto=add</VAR> in the connection
 description or with an explicit<NOBR><VAR> ipsec auto --add name</VAR>
command.</P>
<P>Note that to shut down a connection, you must do:</P>
<PRE>        ipsec auto --down <VAR>name</VAR></PRE>
<P>on<EM> both</EM> gateway machines, even though you only start it from
 one.</P>
<P>If the<VAR> ipsec auto --up</VAR> command doesn't generate any
 errors, do</P>
<PRE>        ipsec look</PRE>
<P>and see if the output looks something like this:</P>
<PRE>foo.spsystems.net Wed Nov 25 22:51:45 EST 1998
-------------------------
10.0.1.0/24 -&gt; 11.0.1.0/24 =&gt; tun0x200@11.0.0.1 esp0x202@11.0.0.1
-------------------------
tun0x200@11.0.0.1 IPv4_Encapsulation: dir=out   10.0.0.1 -&gt; 11.0.0.1
esp0x203@10.0.0.1 3DES-MD5-96_Encryption: dir=in  iv=0xc2cbca5ba42ffbb6  seq=0  bit=0x00000000  win=0  flags=0x0&lt;&gt;
esp0x202@11.0.0.1 3DES-MD5-96_Encryption: dir=out  iv=0xc2cbca5ba42ffbb6  seq=0  bit=0x00000000  win=0  flags=0x0&lt;&gt;
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
11.0.0.0        0.0.0.0         255.255.255.0   U      1500 0          0 eth1
11.0.1.0        11.0.0.1        255.255.255.0   UG     1404 0          0 ipsec0</PRE>
<P>If it does, you're probably in business.</P>
<P>This example shows:</P>
<PRE>        a tunnel              tun0x200 going to 11.0.0.1
        outgoing connection   esp0x202
        incoming connection   esp0x203</PRE>
<P>Both connections use<A href="glossary.html#ESP"> ESP</A> with<A href="glossary.html#3DES">
 3DES</A> encryption and<A href="glossary.html#MD5"> MD5</A>
 authentication.</P>
<P>The routing is:</P>
<PRE>        11.0.0.0    via eth1 and the Internet
        11.0.1.0    via ipsec0 which encrypts and then sends to 11.0.0.1</PRE>
<P>This routes all traffic to the protected network 11.0.1.0/24 through
 an IPsec tunnel to the gateway 11.0.0.1.</P>
<H3><A name="pingtest">Ping tests</A></H3>
<P>If that works, test whether Sunrise can ping Sunset and vice versa.
 Our example setup again is:</P>
<PRE>        Sunset==========West------------------East=========Sunrise
              local net       untrusted net       local net</PRE>
<P>There is no point in testing to or from the gateways themselves; the
 goal is to secure traffic between the subnets, not between the security
 gateways themselves.</P>
<P>In general, pings or other<STRONG> tests using the public interfaces
 of East and/or West are entirely useless</STRONG>. The IPsec tunnel is
 for packets between the two protected subnets and the outside
 interfaces are not on those subnets. Depending on your routing
 configuration, test packets sent via those interfaces will be:</P>
<UL>
<LI>either transmitted in the clear, bypassing the tunnel,</LI>
<LI>or discarded because there is no tunnel in place to handle them</LI>
</UL>
<P>In either case,<STRONG> they tell you nothing about the tunnel</STRONG>
.</P>
<P>Sometimes it will be inconvenient to use the client machines (Sunrise
 and Sunset in our example) for testing. In these cases, use a command
 such as:</P>
<PRE>     traceroute -i eth0 -f 20 192.168.7.1</PRE>
<P>where each of the interfaces specified (eth0 and 192.168.7.1 in the
 example) are<STRONG> on one of the protected subnets</STRONG>, eth0
 being the local gateway's interface on that side and 192.168.7.1 the
 remote gateway's subnet interface. This forces the packets through the
 IPsec tunnel you want to test.</P>
<P>For information on setting things up so that gateways can do IPsec to
 each other or to remote subnets, see<A href="adv_config.html#multitunnel">
 below</A>.</P>
<P>If you have other software set up, test with it as well. Telnet from
 Sunrise to Sunset, browse a web server on the remote net and so on.</P>
<H3><A name="tcpdump">Testing with tcpdump</A></H3>
<P>To verify that all is working, run tcpdump(8) on a machine which can
 listen to the traffic between the gateways.</P>
<P>This is most easily done from a third machine, rather than from one
 of the gateways. On the gateways you may see packets at intermediate
 stages of processing and the result may be confusing.</P>
<P>If the results make no sense at all, or you see &quot;bad physical medium&quot;
 error messages, you probably have an outdated version of tcpdump(8)
 that does not handle IPsec at all. See this<A href="testing.html#tcpdump.test">
 discussion</A>.</P>
<P>If packets look like total garbage, nothing recognizable, all is
 well.</P>
 See our document on<A href="testing.html#verify.crypt"> testing</A> for
 more detail if required.
<H3><A name="conn.shutdown">Shutting down connections</A></H3>
<P>To shut down a connection, you must do:</P>
<PRE>        ipsec auto --down <VAR>name</VAR></PRE>
<P>on<EM> both</EM> gateway machines, even though you only start it from
 one.</P>
<P>Again, you can verify with the same commands. Repeat the ping test.
 Repeat the tcpdump test.</P>
<P>If everything succeeds, congratulations.<STRONG> You now have a
 working Linux FreeS/WAN installation.</STRONG></P>
<H2><A name="links.conf">What next?</A></H2>
<P>At this point you should have a working FreeS/WAN setup. If not, you
 could go back and doublecheck various things above or try:</P>
<P></P>
<UL>
<LI>our<A href="faq.html"> FAQ</A></LI>
<LI>our<A href="trouble.html"> troubleshooting</A> section</LI>
<LI>additional<A href="examples"> configuration examples</A></LI>
</UL>
<P>If all is well so far, you could go to:</P>
<UL>
<LI>more detail on the<A href="ipsec.html"> IPsec protocols</A></LI>
<LI><A href="politics.html">history and politics of cryptography</A></LI>
<LI><A href="adv_config.html">advanced configuration</A>, other ways to
 configure FreeS/WAN connections</LI>
<LI><A href="interop.html">interoperating</A> with other IPsec
 implementations</LI>
</UL>
<P>Of course you might just go off for a beverage or meal at this point
 as well.</P>
<HR>
<A HREF="toc.html">Contents</A>
<A HREF="install.html">Previous</A>
<A HREF="background.html">Next</A>
</BODY>
</HTML>
